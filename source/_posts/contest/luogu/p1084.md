---
title: P1084疫情控制
date: 2022-02-07 17:00:00
categories: acm
tag: luogu
---

{% link '疫情控制' https://www.luogu.com.cn/problem/solution/P1084 [title] %}

```py
# edge of tree
to = []
vw = []
head = []
nxt = []
v_tot = 0
# emery
p = []
# bei zeng
fa, dis = [], []
sta, need = [], []


def add(f, t, w):
    global v_tot
    to.append(t)
    vw.append(w)
    nxt.append(head[f])
    head[f] = v_tot
    v_tot += 1


def dfs(root, now, now_fa):
    vp = head[root]
    while vp > 0:
        son = to[vp]
        w = vw[vp]
        vp = nxt[vp]
        print("root:", root, "son:", son)

        if son != now_fa:
            fa[son][0] = root
            dis[son][0] = w
            for i in range(1, 20):
                fa[son][i] = fa[fa[son][i - 1]][i - 1]
                dis[son][i] = dis[fa[son][i - 1]][i - 1] + dis[son][i - 1]
            dfs(son, now + w, root)


def find_need(root, pre):
    if sta[root]:
        need[root] = False
        return False

    need[root] = True

    vp = head[root]
    while vp > 0:
        son = to[vp]
        vp = nxt[vp]
        if son == pre:
            continue
        if find_need(son, root):
            need[root] = True
            break
        else:
            need[root] = False

    return need[root]


def check(limit, n, m):
    global sta, need, p
    sta = (n + 1) * [False]
    need = (n + 1) * [True]

    prepare = []

    for i in range(m):
        pos = p[i]
        cur = 0
        for j in reversed(range(20)):
            if fa[pos][j] > 1 and cur + dis[pos][j] <= limit:
                pos = fa[pos][j]
                cur += dis[pos][j]
        if fa[pos][0] == 1 and cur + dis[pos][0] <= limit:
            prepare.append([limit - cur - dis[pos][0], pos])
        else:
            sta[pos] = True

    prepare.sort(key=lambda x: x[0])

    vi = head[1]
    while vi > 0:
        son = to[vi]
        find_need(son, 1)

    rest = []
    for item in prepare:
        if fa[item[1]][0] == 1 and need[item[1]] and item[0] < dis[item[1]][0]:
            need[item[1]] = False
        else:
            rest.append(item[0])

    len_r = len(rest)
    need_list = []

    vi = head[1]
    while vi > 0:
        son = to[vi]
        w = vw[vi]
        vi = nxt[vi]
        if need[son]:
            need_list.append(w)

    len_n = len(need_list)

    if len_r < len_n:
        return False

    need_list.sort()

    # print(rest)
    # print(need_list)

    idx_r, idx_n = 0, 0
    while idx_n < len_n and idx_r < len_r:
        if need_list[idx_n] <= rest[idx_r]:
            idx_n += 1
        idx_r += 1

    return idx_n >= len_n


def solve():
    n = int(input().strip())

    global fa, dis, p, head, to, vw, nxt
    fa = (n + 1) * [[]]
    dis = (n + 1) * [[]]
    head = (n + 1) * [0]
    to = []
    vw = []
    nxt = []

    for i in range(n + 1):
        fa[i] = 20 * [0]
        dis[i] = 20 * [0]

    sum = 0
    for i in range(n - 1):
        f, t, w = map(int, input().strip().split())
        add(f, t, w)
        add(t, f, w)
        sum += w

    m = int(input().strip())
    p = list(map(int, input().strip().split()))

    dfs(1, 0, 0)

    l = 0
    r = sum
    ans = -1
    while l <= r:
        mid = (l + r) >> 1
        if check(mid, n, m):
            r = mid - 1
            ans = mid
        else:
            l = mid + 1
    print(ans)


if __name__ == '__main__':
    solve()

# 4
# 1 2 1
# 1 3 2
# 3 4 3
# 2
# 2 2
# 10
# 2 1 3
# 2 3 4
# 1 4 7
# 5 1 9
# 6 1 2
# 4 7 9
# 7 8 8
# 9 8 8
# 1 10 2
# 5
# 2 8 5 4 2


```
